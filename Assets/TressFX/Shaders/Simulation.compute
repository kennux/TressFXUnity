//--------------------------------------------------------------------------------------
// File: TresFXSimulation.hlsl
//
// Physics simulation of hair using compute shaders 
// 
//
// Copyright 2014 ADVANCED MICRO DEVICES, INC.  All Rights Reserved.
//
// AMD is granting you permission to use this software and documentation (if
// any) (collectively, the "Materials") pursuant to the terms and conditions
// of the Software License Agreement included with the Materials.  If you do
// not have a copy of the Software License Agreement, contact your AMD
// representative for a copy.
// You agree that you will not reverse engineer or decompile the Materials,
// in whole or in part, except as allowed by applicable law.
//
// WARRANTY DISCLAIMER: THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND.  AMD DISCLAIMS ALL WARRANTIES, EXPRESS, IMPLIED, OR STATUTORY,
// INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE, NON-INFRINGEMENT, THAT THE SOFTWARE
// WILL RUN UNINTERRUPTED OR ERROR-FREE OR WARRANTIES ARISING FROM CUSTOM OF
// TRADE OR COURSE OF USAGE.  THE ENTIRE RISK ASSOCIATED WITH THE USE OF THE
// SOFTWARE IS ASSUMED BY YOU.
// Some jurisdictions do not allow the exclusion of implied warranties, so
// the above exclusion may not apply to You. 
// 
// LIMITATION OF LIABILITY AND INDEMNIFICATION:  AMD AND ITS LICENSORS WILL
// NOT, UNDER ANY CIRCUMSTANCES BE LIABLE TO YOU FOR ANY PUNITIVE, DIRECT,
// INCIDENTAL, INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES ARISING FROM USE OF
// THE SOFTWARE OR THIS AGREEMENT EVEN IF AMD AND ITS LICENSORS HAVE BEEN
// ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.  
// In no event shall AMD's total liability to You for all damages, losses,
// and causes of action (whether in contract, tort (including negligence) or
// otherwise) exceed the amount of $100 USD.  You agree to defend, indemnify
// and hold harmless AMD and its licensors, and any of their directors,
// officers, employees, affiliates or agents from and against any and all
// loss, damage, liability and other expenses (including reasonable attorneys'
// fees), resulting from Your use of the Software or violation of the terms and
// conditions of this Agreement.  
//
// U.S. GOVERNMENT RESTRICTED RIGHTS: The Materials are provided with "RESTRICTED
// RIGHTS." Use, duplication, or disclosure by the Government is subject to the
// restrictions as set forth in FAR 52.227-14 and DFAR252.227-7013, et seq., or
// its successor.  Use of the Materials by the Government constitutes
// acknowledgement of AMD's proprietary rights in them.
// 
// EXPORT RESTRICTIONS: The Materials may be subject to export restrictions as
// stated in the Software License Agreement.
//
//--------------------------------------------------------------------------------------

#pragma kernel IntegrationAndGlobalShapeConstraints
#pragma kernel LocalShapeConstraints
#pragma kernel LocalShapeConstraintsWithIteration
#pragma kernel LengthConstriantsWindAndCollision
#pragma kernel UpdateFollowHairVertices
#pragma kernel PrepareFollowHairBeforeTurningIntoGuide

// If you change the value below, you must change it in TressFXSimulation.cs as well. 
#define THREAD_GROUP_SIZE 64
#define MAX_VERTS_PER_STRAND 16

//constants that change frame to frame
float4x4 g_ModelTransformForHead;

float4 g_ModelRotateForHead; // quaternion

float4 g_Wind;
float4 g_Wind1;
float4 g_Wind2;
float4 g_Wind3;

int g_NumLengthConstraintIterations;
int g_bCollision;

float g_GravityMagnitude;
float g_TimeStep;

uint g_NumOfStrandsPerThreadGroup;
int g_NumFollowHairsPerOneGuideHair;

int	g_bWarp;
uint g_NumLocalShapeMatchingIterations;
	
float3	g_cc0_center;
float	g_cc0_radius;
float3	g_cc1_center;
float	g_cc1_radius;
float3	g_cc2_center;
float	g_cc2_radius;
float	g_cc0_radius2;
float	g_cc1_radius2;
float	g_cc2_radius2;

RWStructuredBuffer<float4> g_HairVertexPositions		: register(u0); 
RWStructuredBuffer<float4> g_HairVertexPositionsPrev	: register(u1); 
RWStructuredBuffer<float4> g_HairVertexTangents			: register(u2); 
RWStructuredBuffer<float4> g_InitialHairPositions		: register(u3);
RWStructuredBuffer<float4> g_GlobalRotations			: register(u4); 
RWStructuredBuffer<float4> g_LocalRotations				: register(u5); 

// RO Buffer
RWStructuredBuffer<float>	g_HairRestLengthSRV			: register(t0);
RWStructuredBuffer<int>		g_HairStrandType			: register(t1); 
RWStructuredBuffer<float4>	g_HairRefVecsInLocalFrame	: register(t2); 
RWStructuredBuffer<float4>	g_FollowHairRootOffset   	: register(t3); 

// Config arrays
float g_Damping0;
float g_Damping1;
float g_Damping2;
float g_Damping3;
float g_StiffnessForLocalShapeMatching0;
float g_StiffnessForLocalShapeMatching1;
float g_StiffnessForLocalShapeMatching2;
float g_StiffnessForLocalShapeMatching3;
float g_StiffnessForGlobalShapeMatching0;
float g_StiffnessForGlobalShapeMatching1;
float g_StiffnessForGlobalShapeMatching2;
float g_StiffnessForGlobalShapeMatching3;
float g_GlobalShapeMatchingEffectiveRange0;
float g_GlobalShapeMatchingEffectiveRange1;
float g_GlobalShapeMatchingEffectiveRange2;
float g_GlobalShapeMatchingEffectiveRange3;

groupshared float4 sharedPos[THREAD_GROUP_SIZE];
groupshared float4 sharedTangent[THREAD_GROUP_SIZE];
groupshared float  sharedLength[THREAD_GROUP_SIZE];


//--------------------------------------------------------------------------------------
// 
//	Helper Functions for the main simulation shaders
//
//--------------------------------------------------------------------------------------
bool IsMovable(float4 particle)
{
    if ( particle.w > 0 )
        return true;
    return false;      
}

float GetDamping(uint strandType)
{
	if (strandType == 0)
		return g_Damping0;
	if (strandType == 1)
		return g_Damping1;
	if (strandType == 2)
		return g_Damping2;
	if (strandType == 3)
		return g_Damping3;
	return 0.03;
}

float GetStiffnessForLocalShapeMatching(uint strandType)
{
	if (strandType == 0)
		return g_StiffnessForLocalShapeMatching0;
	if (strandType == 1)
		return g_StiffnessForLocalShapeMatching1;
	if (strandType == 2)
		return g_StiffnessForLocalShapeMatching2;
	if (strandType == 3)
		return g_StiffnessForLocalShapeMatching3;
	return 0.95;
}

float GetStiffnessForGlobalShapeMatching(uint strandType)
{
	if (strandType == 0)
		return g_StiffnessForGlobalShapeMatching0;
	if (strandType == 1)
		return g_StiffnessForGlobalShapeMatching1;
	if (strandType == 2)
		return g_StiffnessForGlobalShapeMatching2;
	if (strandType == 3)
		return g_StiffnessForGlobalShapeMatching3;
	return 0.2;
}

float GetGlobalShapeMatchingEffectiveRange(uint strandType)
{
	if (strandType == 0)
		return g_GlobalShapeMatchingEffectiveRange0;
	if (strandType == 1)
		return g_GlobalShapeMatchingEffectiveRange1;
	if (strandType == 2)
		return g_GlobalShapeMatchingEffectiveRange2;
	if (strandType == 3)
		return g_GlobalShapeMatchingEffectiveRange3;
	return 0.3;
}

float2 ConstraintMultiplier(float4 particle0, float4 particle1)
{
    if (IsMovable(particle0)) 
    {
        if (IsMovable(particle1))
            return float2(0.5, 0.5);
        else
            return float2(1, 0);
    }
    else 
    {
        if (IsMovable(particle1))
            return float2(0, 1);
        else
            return float2(0, 0);
    }    
}

float4 MakeQuaternion(float angle_radian, float3 axis)
{
    // create quaternion using angle and rotation axis
    float4 quaternion;
    float halfAngle = 0.5f * angle_radian;
    float sinHalf = sin(halfAngle);

    quaternion.w = cos(halfAngle);
    quaternion.xyz = sinHalf * axis.xyz;

    return quaternion;
}

float4 InverseQuaternion(float4 q)
{
    float lengthSqr = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w;

    if ( lengthSqr < 0.001 )
        return float4(0, 0, 0, 1.0f);

    q.x = -q.x / lengthSqr;
    q.y = -q.y / lengthSqr;
    q.z = -q.z / lengthSqr;
    q.w = q.w / lengthSqr;

    return q;
}

float3 MultQuaternionAndVector(float4 q, float3 v)
{
    float3 uv, uuv;
    float3 qvec = float3(q.x, q.y, q.z);
    uv = cross(qvec, v);
    uuv = cross(qvec, uv);
    uv *= (2.0f * q.w);
    uuv *= 2.0f;

    return v + uv + uuv;
}

float4 MultQuaternionAndQuaternion(float4 qA, float4 qB)
{
    float4 q;

    q.w = qA.w * qB.w - qA.x * qB.x - qA.y * qB.y - qA.z * qB.z;
    q.x = qA.w * qB.x + qA.x * qB.w + qA.y * qB.z - qA.z * qB.y;
    q.y = qA.w * qB.y + qA.y * qB.w + qA.z * qB.x - qA.x * qB.z;
    q.z = qA.w * qB.z + qA.z * qB.w + qA.x * qB.y - qA.y * qB.x;
    
    return q;
}

void ApplyDistanceConstraint(inout float4 pos0, inout float4 pos1, float targetDistance, float stiffness = 1.0)
{
    float3 delta = pos1.xyz - pos0.xyz;
    float distance = max(length(delta), 1e-7);
    float stretching = 1 - targetDistance / distance;
    delta = stretching * delta;
    float2 multiplier = ConstraintMultiplier(pos0, pos1);
    
    pos0.xyz += multiplier[0] * delta * stiffness;
    pos1.xyz -= multiplier[1] * delta * stiffness;
}

void CalcIndicesInVertexLevelTotal(uint local_id, uint group_id, inout uint globalStrandIndex, inout uint localStrandIndex, inout uint globalVertexIndex, inout uint localVertexIndex, inout uint numVerticesInTheStrand, inout uint indexForSharedMem, inout uint strandType)
{
	indexForSharedMem = local_id;
	numVerticesInTheStrand = (THREAD_GROUP_SIZE / g_NumOfStrandsPerThreadGroup);

	localStrandIndex = local_id % g_NumOfStrandsPerThreadGroup;
	globalStrandIndex = group_id * g_NumOfStrandsPerThreadGroup + localStrandIndex;	
	localVertexIndex = (local_id - localStrandIndex) / g_NumOfStrandsPerThreadGroup;	
	
    strandType = g_HairStrandType.Load(globalStrandIndex);
	globalVertexIndex = globalStrandIndex * numVerticesInTheStrand + localVertexIndex;
}

void CalcIndicesInVertexLevelMaster(uint local_id, uint group_id, inout uint globalStrandIndex, inout uint localStrandIndex, inout uint globalVertexIndex, inout uint localVertexIndex, inout uint numVerticesInTheStrand, inout uint indexForSharedMem, inout uint strandType)
{
	indexForSharedMem = local_id;
	numVerticesInTheStrand = (THREAD_GROUP_SIZE / g_NumOfStrandsPerThreadGroup);

	localStrandIndex = local_id % g_NumOfStrandsPerThreadGroup;
	globalStrandIndex = group_id * g_NumOfStrandsPerThreadGroup + localStrandIndex;	
	globalStrandIndex *= (g_NumFollowHairsPerOneGuideHair+1);
	localVertexIndex = (local_id - localStrandIndex) / g_NumOfStrandsPerThreadGroup;	
	
    strandType = g_HairStrandType.Load(globalStrandIndex);
	globalVertexIndex = globalStrandIndex * numVerticesInTheStrand + localVertexIndex;
}

void CalcIndicesInStrandLevelTotal(uint local_id, uint group_id, inout uint globalStrandIndex, inout uint numVerticesInTheStrand, inout uint globalRootVertexIndex, inout uint strandType)
{
	globalStrandIndex = THREAD_GROUP_SIZE*group_id + local_id;	
	numVerticesInTheStrand = (THREAD_GROUP_SIZE / g_NumOfStrandsPerThreadGroup);
    strandType = g_HairStrandType.Load(globalStrandIndex);
	globalRootVertexIndex = globalStrandIndex * numVerticesInTheStrand;
}

void CalcIndicesInStrandLevelMaster(uint local_id, uint group_id, inout uint globalStrandIndex, inout uint numVerticesInTheStrand, inout uint globalRootVertexIndex, inout uint strandType)
{
	globalStrandIndex = THREAD_GROUP_SIZE*group_id + local_id;	
	globalStrandIndex *= (g_NumFollowHairsPerOneGuideHair+1);
	numVerticesInTheStrand = (THREAD_GROUP_SIZE / g_NumOfStrandsPerThreadGroup);
    strandType = g_HairStrandType.Load(globalStrandIndex);
	globalRootVertexIndex = globalStrandIndex * numVerticesInTheStrand;
}

//--------------------------------------------------------------------------------------
// 
//	Integrate
//
//  Uses Verlet integration to calculate the new position for the current time step
//
//--------------------------------------------------------------------------------------
float4 Integrate(float4 curPosition, float4 oldPosition, float4 initialPos, float4 force, int globalVertexIndex, int localVertexIndex, int numVerticesInTheStrand, float dampingCoeff = 1.0f)
{  
    float4 outputPos = curPosition;

    force.xyz += g_GravityMagnitude * float3(0, -1.0f, 0);
    outputPos.xyz = curPosition.xyz + (1.0 - dampingCoeff)*(curPosition.xyz - oldPosition.xyz) + force.xyz*g_TimeStep*g_TimeStep; 
    
    return outputPos;  
}


struct CollisionCapsule
{
	float4 p1; // xyz = position 1 of capsule, w = radius
	float4 p2; // xyz = position 2 of capsule, w = radius * radius
};

//--------------------------------------------------------------------------------------
// 
//	CapsuleCollision
//
//  Moves the position based on collision with capsule
//
//--------------------------------------------------------------------------------------
bool CapsuleCollision(float4 curPosition, float4 oldPosition, inout float3 newPosition, CollisionCapsule cc, bool bOnlyFirstSphere = false, float friction = 0.4f)
{
	const float radius = cc.p1.w;
	const float radius2 = cc.p2.w;
		
	if ( !IsMovable(curPosition) )
		return false;
			
	float3 segment = cc.p2.xyz - cc.p1.xyz;
	float3 delta1 = curPosition.xyz - cc.p1.xyz;
	float3 delta2 = cc.p2.xyz - curPosition.xyz;
		
	float dist1 = dot(delta1, segment);
	float dist2 = dot(delta2, segment);
		
	// colliding with sphere 1
	if ( dist1 < 0.f )
	{
		if ( dot(delta1, delta1) < radius2 )
		{
			float3 n = normalize(delta1);
			newPosition = radius * n + cc.p1.xyz;
			return true;
		}

		return false;
	}

	if ( bOnlyFirstSphere )
		return false;
		
	// colliding with sphere 2
	if ( dist2 < 0.f )
	{
		if ( dot(delta2, delta2) < radius2 )
		{
			float3 n = normalize(-delta2);
			newPosition = radius * n + cc.p2.xyz;
			return true;
		}

		return false;
	}
		
	// colliding with middle cylinder
	float3 x = (dist1 * cc.p2.xyz + dist2 * cc.p1.xyz) / (dist1 + dist2);
	float3 delta = curPosition.xyz - x;
		
	if ( dot(delta, delta) < radius2 )
	{
		float3 n = normalize(delta);
		float3 vec = curPosition.xyz - oldPosition.xyz;
		float3 segN = normalize(segment);
		float3 vecTangent = dot(vec, segN) * segN;
		float3 vecNormal = vec - vecTangent;
		newPosition.xyz = oldPosition.xyz + friction * vecTangent + (vecNormal + radius * n - delta);
		return true;
	}
		
	return false;
}

//--------------------------------------------------------------------------------------
// 
//	UpdateFinalVertexPositions
//
//  Updates the  hair vertex positions based on the physics simulation
//
//--------------------------------------------------------------------------------------
void UpdateFinalVertexPositions(float4 oldPosition, float4 newPosition, int globalVertexIndex, int localVertexIndex, int numVerticesInTheStrand)
{ 
	g_HairVertexPositionsPrev[globalVertexIndex] = oldPosition;        
	g_HairVertexPositions[globalVertexIndex] = newPosition;
}

//--------------------------------------------------------------------------------------
// 
//	IntegrationAndGlobalShapeConstraints
//
//  Compute shader to simulate the gravitational force with integration and to maintain the
//  global shape constraints.
//
// One thread computes one vertex.
//
//--------------------------------------------------------------------------------------
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void IntegrationAndGlobalShapeConstraints(uint GIndex : SV_GroupIndex,
                  uint3 GId : SV_GroupID,
                  uint3 DTid : SV_DispatchThreadID)
{
	uint globalStrandIndex, localStrandIndex, globalVertexIndex, localVertexIndex, numVerticesInTheStrand, indexForSharedMem, strandType;
	CalcIndicesInVertexLevelMaster(GIndex, GId.x, globalStrandIndex, localStrandIndex, globalVertexIndex, localVertexIndex, numVerticesInTheStrand, indexForSharedMem, strandType);
	
    float4 currentPos = float4(0, 0, 0, 0); // position when this step starts. In other words, a position from the last step. 
    float4 initialPos = float4(0, 0, 0, 0); // rest position

    // Copy data into shared memory 
    initialPos = g_InitialHairPositions[globalVertexIndex];
    initialPos.xyz = mul(float4( initialPos.xyz, 1), g_ModelTransformForHead).xyz;
	if (g_bWarp)
		currentPos = initialPos;
	else
		currentPos = sharedPos[indexForSharedMem] = g_HairVertexPositions[globalVertexIndex];
        
    GroupMemoryBarrierWithGroupSync();

    // Integrate
	float dampingCoeff = GetDamping(strandType);

    float4 oldPos;
	if (g_bWarp)
		oldPos = currentPos;
	else
		oldPos = g_HairVertexPositionsPrev[globalVertexIndex];
    float4 force = float4(0, 0, 0, 0);

    if ( IsMovable(currentPos) )  
        sharedPos[indexForSharedMem] = Integrate(currentPos, oldPos, initialPos, force, globalVertexIndex, localVertexIndex, numVerticesInTheStrand, dampingCoeff); 
    else
        sharedPos[indexForSharedMem] = initialPos;

    // Global Shape Constraints
    float stiffnessForGlobalShapeMatching = GetStiffnessForGlobalShapeMatching(strandType);
    float globalShapeMatchingEffectiveRange = GetGlobalShapeMatchingEffectiveRange(strandType);
    
    if ( stiffnessForGlobalShapeMatching > 0 && globalShapeMatchingEffectiveRange )
    {
        if ( IsMovable(sharedPos[indexForSharedMem]) )  
        {
            if ( (float)localVertexIndex < globalShapeMatchingEffectiveRange * (float)numVerticesInTheStrand )
            {
                float factor = stiffnessForGlobalShapeMatching;
                float3 del = factor * (initialPos - sharedPos[indexForSharedMem]).xyz;
                sharedPos[indexForSharedMem].xyz += del;
            }
        }
    }

    // update global position buffers
    UpdateFinalVertexPositions(currentPos, sharedPos[indexForSharedMem], globalVertexIndex, localVertexIndex, numVerticesInTheStrand);
}

//--------------------------------------------------------------------------------------
// 
//	LocalShapeConstraints
//
//  Compute shader to maintain the local shape constraints.
//
// One thread computes one strand.
//
//--------------------------------------------------------------------------------------
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void LocalShapeConstraints(uint GIndex : SV_GroupIndex,
                  uint3 GId : SV_GroupID,
                  uint3 DTid : SV_DispatchThreadID)
{
	uint local_id, group_id, globalStrandIndex, numVerticesInTheStrand, globalRootVertexIndex, strandType;
	CalcIndicesInStrandLevelMaster(GIndex, GId.x, globalStrandIndex, numVerticesInTheStrand, globalRootVertexIndex, strandType);

	// stiffness for local shape constraints
	float stiffnessForLocalShapeMatching = GetStiffnessForLocalShapeMatching(strandType);

	//1.0 for stiffness makes things unstable sometimes.
	stiffnessForLocalShapeMatching = 0.5f*min(stiffnessForLocalShapeMatching, 0.95f);

	//--------------------------------------------
	// Local shape constraint for bending/twisting 
	//--------------------------------------------    
	{
		float4 pos = g_HairVertexPositions[globalRootVertexIndex+1];
		float4 pos_plus_one;
		uint globalVertexIndex = 0;
		float4 rotGlobal = g_GlobalRotations[globalRootVertexIndex];
	
		for ( uint localVertexIndex = 1; localVertexIndex < numVerticesInTheStrand-1; localVertexIndex++ )
		{
			globalVertexIndex = globalRootVertexIndex + localVertexIndex;
			pos_plus_one = g_HairVertexPositions[globalVertexIndex+1];

			//--------------------------------
			// Update position i and i_plus_1
			//--------------------------------
			float4 rotGlobalWorld = MultQuaternionAndQuaternion(g_ModelRotateForHead, rotGlobal); 

			float3 orgPos_i_plus_1_InLocalFrame_i = g_HairRefVecsInLocalFrame[globalVertexIndex+1].xyz;	
			float3 orgPos_i_plus_1_InGlobalFrame = MultQuaternionAndVector(rotGlobalWorld, orgPos_i_plus_1_InLocalFrame_i) + pos.xyz;

			float3 del = stiffnessForLocalShapeMatching * (orgPos_i_plus_1_InGlobalFrame - pos_plus_one.xyz).xyz;

			if ( IsMovable(pos) )
				pos.xyz -= del.xyz;

			if ( IsMovable(pos_plus_one) )
				pos_plus_one.xyz += del.xyz;
	
			//---------------------------
			// Update local/global frames
			//---------------------------
			float4 invRotGlobalWorld = InverseQuaternion(rotGlobalWorld);	
			float3 vec = normalize(pos_plus_one.xyz - pos.xyz);		
    
			float3 x_i_plus_1_frame_i = normalize(MultQuaternionAndVector(invRotGlobalWorld, vec));
			float3 e = float3(1.0f, 0, 0);
			float3 rotAxis = cross(e, x_i_plus_1_frame_i);
    
			if ( length(rotAxis) > 0.001 )
			{
				float angle_radian = acos(dot(e, x_i_plus_1_frame_i));
				rotAxis = normalize(rotAxis);

				float4 localRot = MakeQuaternion(angle_radian, rotAxis);
				rotGlobal = MultQuaternionAndQuaternion(rotGlobal, localRot);
			}	

			g_HairVertexPositions[globalVertexIndex].xyz = pos.xyz;			
			g_HairVertexPositions[globalVertexIndex+1].xyz = pos_plus_one.xyz;

			pos = pos_plus_one;
		}	  
	}

	return;
}

//--------------------------------------------------------------------------------------
// 
//	LocalShapeConstraintsWithIteration
//
//  Compute shader to maintain the local shape constraints. This is the same as
//  the LocalShapeConstraints shader, except the iterations are done on the GPU
//  instead of multiple dispatch calls on the CPU, for better performance
//
//--------------------------------------------------------------------------------------
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void LocalShapeConstraintsWithIteration(uint GIndex : SV_GroupIndex,
                  uint3 GId : SV_GroupID,
                  uint3 DTid : SV_DispatchThreadID)
{
	uint local_id, group_id, globalStrandIndex, numVerticesInTheStrand, globalRootVertexIndex, strandType;
	CalcIndicesInStrandLevelMaster(GIndex, GId.x, globalStrandIndex, numVerticesInTheStrand, globalRootVertexIndex, strandType);

	// stiffness for local shape constraints
	float stiffnessForLocalShapeMatching = GetStiffnessForLocalShapeMatching(strandType);

	//1.0 for stiffness makes things unstable sometimes.
	stiffnessForLocalShapeMatching = 0.5f*min(stiffnessForLocalShapeMatching, 0.95f);

	//------------------------------
	// Copy strand data into registers, for faster iteration
	//------------------------------
	uint globalVertexIndex = 0;
	float4 sharedStrandPos[MAX_VERTS_PER_STRAND];
	uint localVertexIndex = 0;
	
	for ( localVertexIndex = 0; localVertexIndex < numVerticesInTheStrand; localVertexIndex++ )
	{
		globalVertexIndex = globalRootVertexIndex + localVertexIndex;
		sharedStrandPos[localVertexIndex] = g_HairVertexPositions[globalVertexIndex];
	}

	//--------------------------------------------
	// Local shape constraint for bending/twisting 
	//--------------------------------------------    
	for ( uint iterations = 0; iterations < g_NumLocalShapeMatchingIterations; iterations++)
	{
		float4 pos = sharedStrandPos[1];
		float4 rotGlobal = g_GlobalRotations[globalRootVertexIndex];
	
		for ( uint localVertexIndex = 1; localVertexIndex < numVerticesInTheStrand-1; localVertexIndex++ )
		{
			globalVertexIndex = globalRootVertexIndex + localVertexIndex;
			float4 pos_plus_one = sharedStrandPos[localVertexIndex+1];

			//--------------------------------
			// Update position i and i_plus_1
			//--------------------------------
			float4 rotGlobalWorld = MultQuaternionAndQuaternion(g_ModelRotateForHead, rotGlobal); 

			float3 orgPos_i_plus_1_InLocalFrame_i = g_HairRefVecsInLocalFrame[globalVertexIndex+1].xyz;	
			float3 orgPos_i_plus_1_InGlobalFrame = MultQuaternionAndVector(rotGlobalWorld, orgPos_i_plus_1_InLocalFrame_i) + pos.xyz;

			float3 del = stiffnessForLocalShapeMatching * (orgPos_i_plus_1_InGlobalFrame - pos_plus_one.xyz).xyz;

			if ( IsMovable(pos) )
				pos.xyz -= del.xyz;

			if ( IsMovable(pos_plus_one) )
				pos_plus_one.xyz += del.xyz;
	
			//---------------------------
			// Update local/global frames
			//---------------------------
			float4 invRotGlobalWorld = InverseQuaternion(rotGlobalWorld);	
			float3 vec = normalize(pos_plus_one.xyz - pos.xyz);		
    
			float3 x_i_plus_1_frame_i = normalize(MultQuaternionAndVector(invRotGlobalWorld, vec));
			float3 e = float3(1.0f, 0, 0);
			float3 rotAxis = cross(e, x_i_plus_1_frame_i);
    
			if ( length(rotAxis) > 0.001 )
			{
				float angle_radian = acos(dot(e, x_i_plus_1_frame_i));
				rotAxis = normalize(rotAxis);

				float4 localRot = MakeQuaternion(angle_radian, rotAxis);
				rotGlobal = MultQuaternionAndQuaternion(rotGlobal, localRot);
			}	

			sharedStrandPos[localVertexIndex].xyz = pos.xyz;			
			sharedStrandPos[localVertexIndex+1].xyz = pos_plus_one.xyz;

			pos = pos_plus_one;
		}	  
	}

	for ( localVertexIndex = 0; localVertexIndex < numVerticesInTheStrand; localVertexIndex++ )
	{
		globalVertexIndex = globalRootVertexIndex + localVertexIndex;
		g_HairVertexPositions[globalVertexIndex] = sharedStrandPos[localVertexIndex];
	}

	return;
}

//--------------------------------------------------------------------------------------
// 
//	LengthConstriantsWindAndCollision
//
//  Compute shader to move the vertex position based on wind, maintain the lenght constraints
//  and handles collisions.
//
// One thread computes one vertex.
//
//--------------------------------------------------------------------------------------
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void LengthConstriantsWindAndCollision(uint GIndex : SV_GroupIndex,
                  uint3 GId : SV_GroupID,
                  uint3 DTid : SV_DispatchThreadID)
{
	uint globalStrandIndex, localStrandIndex, globalVertexIndex, localVertexIndex, numVerticesInTheStrand, indexForSharedMem, strandType;
	CalcIndicesInVertexLevelMaster(GIndex, GId.x, globalStrandIndex, localStrandIndex, globalVertexIndex, localVertexIndex, numVerticesInTheStrand, indexForSharedMem, strandType);
	
	uint numOfStrandsPerThreadGroup = g_NumOfStrandsPerThreadGroup;
				
    //------------------------------
    // Copy data into shared memory
    //------------------------------
    sharedPos[indexForSharedMem] = g_HairVertexPositions[globalVertexIndex];
    sharedLength[indexForSharedMem] = g_HairRestLengthSRV[globalVertexIndex]; 
    GroupMemoryBarrierWithGroupSync();

	//------------
	// Wind
	//------------
	if ( g_Wind.x != 0 || g_Wind.y != 0 || g_Wind.z != 0 )
	{  
		if ( localVertexIndex >= 2 && localVertexIndex < numVerticesInTheStrand-1 )
		{
			// combining four winds.
			float a = ((float)(globalStrandIndex % 20))/20.0f;
			float3	w = a*g_Wind.xyz + (1.0f-a)*g_Wind1.xyz + a*g_Wind2.xyz + (1.0f-a)*g_Wind3.xyz;

			uint sharedIndex = localVertexIndex * numOfStrandsPerThreadGroup + localStrandIndex;

			float3 v = sharedPos[sharedIndex].xyz - sharedPos[sharedIndex+numOfStrandsPerThreadGroup].xyz;
			float3 force = -cross(cross(v, w), v);
			sharedPos[sharedIndex].xyz += force*g_TimeStep*g_TimeStep; 				
		}
	}

	GroupMemoryBarrierWithGroupSync();

	//----------------------------
	// Enforce length constraints
	//----------------------------
	uint a = floor(numVerticesInTheStrand/2.0f);
	uint b = floor((numVerticesInTheStrand-1)/2.0f); 
		
	for ( int iterationE=0; iterationE < g_NumLengthConstraintIterations; iterationE++ )
	{
		uint sharedIndex = 2*localVertexIndex * numOfStrandsPerThreadGroup + localStrandIndex;

		if( localVertexIndex < a )
			ApplyDistanceConstraint(sharedPos[sharedIndex], sharedPos[sharedIndex+numOfStrandsPerThreadGroup], sharedLength[sharedIndex].x);

		GroupMemoryBarrierWithGroupSync();

		if( localVertexIndex < b )
			ApplyDistanceConstraint(sharedPos[sharedIndex+numOfStrandsPerThreadGroup], sharedPos[sharedIndex+numOfStrandsPerThreadGroup*2], sharedLength[sharedIndex+numOfStrandsPerThreadGroup].x);

		GroupMemoryBarrierWithGroupSync();
	}


	//-------------------------------------------------
    // Collision handling hard-code collision shapes
    //-------------------------------------------------
	bool bColDetected = false;
	float4 oldPos = g_HairVertexPositionsPrev[globalVertexIndex];
	
    if ( g_bCollision > 0 )
    {
		float3 newPos;

        {
            float3 centerSphere = g_cc0_center;
            centerSphere = mul(float4( centerSphere.xyz, 1), g_ModelTransformForHead).xyz;
            float radius = g_cc0_radius;

			CollisionCapsule cc;
			cc.p1.xyz = centerSphere;
			cc.p1.w = radius;
			cc.p2.xyz = centerSphere + float3(0.0,1.0,0.0);
			cc.p2.w = g_cc0_radius2;
			
			bColDetected = CapsuleCollision(sharedPos[indexForSharedMem], oldPos, newPos, cc, true);

			if ( bColDetected )
				sharedPos[indexForSharedMem].xyz = newPos;
        }

        {
            float3 centerSphere = g_cc1_center;
            centerSphere = mul(float4( centerSphere.xyz, 1), g_ModelTransformForHead).xyz;
            float radius = g_cc1_radius;

			CollisionCapsule cc;
			cc.p1.xyz = centerSphere;
			cc.p1.w = radius;
			cc.p2.xyz = centerSphere + float3(0.0,1.0,0.0);
			cc.p2.w = g_cc1_radius2;
			
			bColDetected = CapsuleCollision(sharedPos[indexForSharedMem], oldPos, newPos, cc, true);

			if ( bColDetected )
				sharedPos[indexForSharedMem].xyz = newPos;
        }

        {
            float3 centerSphere = g_cc2_center;
            centerSphere = mul(float4( centerSphere.xyz, 1), g_ModelTransformForHead).xyz;
            float radius = g_cc2_radius;

			CollisionCapsule cc;
			cc.p1.xyz = centerSphere;
			cc.p1.w = radius;
			cc.p2.xyz = centerSphere + float3(0.0,1.0,0.0);
			cc.p2.w =  g_cc2_radius2;
			
			bColDetected = CapsuleCollision(sharedPos[indexForSharedMem], oldPos, newPos, cc, true);

			if ( bColDetected )
				sharedPos[indexForSharedMem].xyz = newPos;
        }
    }

    GroupMemoryBarrierWithGroupSync();
	    
    //-------------------
    // Compute tangent
    //-------------------
    float3 tangent = sharedPos[indexForSharedMem+numOfStrandsPerThreadGroup].xyz - sharedPos[indexForSharedMem].xyz;
    g_HairVertexTangents[globalVertexIndex].xyz = normalize(tangent);
	
    //---------------------------------------
    // update global position buffers
    //---------------------------------------	
	g_HairVertexPositions[globalVertexIndex] = sharedPos[indexForSharedMem];
		
	if ( bColDetected )
		g_HairVertexPositionsPrev[globalVertexIndex] = sharedPos[indexForSharedMem];
	
	return;
}

// One thread computes one vertex. 
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void UpdateFollowHairVertices(uint GIndex : SV_GroupIndex,
							  uint3 GId : SV_GroupID,
							  uint3 DTid : SV_DispatchThreadID)
{
	uint globalStrandIndex, localStrandIndex, globalVertexIndex, localVertexIndex, numVerticesInTheStrand, indexForSharedMem, strandType;
	CalcIndicesInVertexLevelMaster(GIndex, GId.x, globalStrandIndex, localStrandIndex, globalVertexIndex, localVertexIndex, numVerticesInTheStrand, indexForSharedMem, strandType);
	
    sharedPos[indexForSharedMem] = g_HairVertexPositions[globalVertexIndex];
	sharedTangent[indexForSharedMem] = g_HairVertexTangents[globalVertexIndex];
    GroupMemoryBarrierWithGroupSync();

	for ( int i = 0; i < g_NumFollowHairsPerOneGuideHair; i++ )
	{
		int globalFollowVertexIndex = globalVertexIndex + numVerticesInTheStrand * (i + 1);
		float factor = 5.0f*(float)localVertexIndex/(float)numVerticesInTheStrand + 1.0f; // 5.0 and 1.0 should match the in CTressFXAssetLoader::GenerateFollowHairs() in TressFXAssetLoader.cpp
		float3 followPos = sharedPos[indexForSharedMem].xyz + factor*g_FollowHairRootOffset[globalStrandIndex+i+1].xyz;

		g_HairVertexPositions[globalFollowVertexIndex].xyz = followPos;
		g_HairVertexTangents[globalFollowVertexIndex] = sharedTangent[indexForSharedMem];
	}

	return;
}

// One thread computes one vertex. 
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void PrepareFollowHairBeforeTurningIntoGuide(uint GIndex : SV_GroupIndex,
											 uint3 GId : SV_GroupID,
											 uint3 DTid : SV_DispatchThreadID)
{
	uint globalStrandIndex, localStrandIndex, globalVertexIndex, localVertexIndex, numVerticesInTheStrand, indexForSharedMem, strandType;
	CalcIndicesInVertexLevelMaster(GIndex, GId.x, globalStrandIndex, localStrandIndex, globalVertexIndex, localVertexIndex, numVerticesInTheStrand, indexForSharedMem, strandType);
	
    sharedPos[indexForSharedMem] = g_HairVertexPositions[globalVertexIndex];
    GroupMemoryBarrierWithGroupSync();

	for ( int i = 0; i < g_NumFollowHairsPerOneGuideHair; i++ )
	{
		int globalFollowVertexIndex = globalVertexIndex + numVerticesInTheStrand * (i + 1);
		g_HairVertexPositionsPrev[globalFollowVertexIndex].xyz = g_HairVertexPositions[globalFollowVertexIndex].xyz;
	}

	return;
}